<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Live Audio Share Â· Listener</title>
    <script src="/socket.io/socket.io.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>

<body class="listener-page">
    <div class="container">
        <div class="page-header">
            <div class="eyebrow" id="audioStatus">Waiting...</div>
            <h1>Live Listener</h1>
            <p>High-fidelity low latency audio stream</p>
        </div>

        <div id="audioVisualizer" class="visualizer-bars"></div>

        <div class="controls" style="flex-direction: column; width: 100%; max-width: 320px; margin: 0 auto;">
            <button id="enableAudio" class="btn btn-primary" style="width: 100%; justify-content: center;">Enable Audio
                Stream</button>
            <button id="muteAudio" class="btn btn-secondary"
                style="width: 100%; display:none; justify-content: center;">Mute Audio</button>

            <div class="volume-control"
                style="width: 100%; display: flex; align-items: center; gap: 12px; margin-top: 16px;">
                <span class="btn-icon">ðŸ”Š</span>
                <input id="volumeSlider" type="range" min="0" max="100" value="100" />
            </div>
            <div id="volumeDisplay" style="font-size: 0.8rem; color: var(--text-tertiary);">100%</div>
        </div>

        <div style="text-align: center; margin-top: 32px;">
            <div id="connectionStatus" style="font-size: 0.8rem; color: var(--text-secondary);">Connecting...</div>
            <div id="clientsCount" style="font-size: 0.75rem; color: var(--text-tertiary);">0 listeners</div>
            <div id="qualityStats"
                style="font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: var(--text-tertiary); margin-top: 8px;">
            </div>
        </div>
    </div>
    <div id="notification" class="notification"></div>

    <script>
        let socket, pc, audioEl, hostIdRef = null; const bars = []; let muted = false, volume = 1.0;
        const qs = id => document.getElementById(id);
        const audioStatus = qs('audioStatus'), connectionStatus = qs('connectionStatus'), clientsCount = qs('clientsCount'), vis = qs('audioVisualizer'), volumeSlider = qs('volumeSlider'), volumeDisplay = qs('volumeDisplay'), enableBtn = qs('enableAudio'), muteBtn = qs('muteAudio'), note = qs('notification'), qualityStats = qs('qualityStats');

        const setStatus = (msg, type) => {
            audioStatus.textContent = msg;
            // Map old classes to new CSS logic or just text
            if (type === 'error') audioStatus.style.color = 'var(--danger)';
            else if (type === 'live') audioStatus.style.color = 'var(--success)';
            else audioStatus.style.color = 'var(--accent-glow)';
        };

        document.addEventListener('DOMContentLoaded', () => { initBars(); initSocket(); bindUi(); });

        function initBars() {
            vis.innerHTML = '';
            for (let i = 0; i < 20; i++) {
                const b = document.createElement('div');
                b.className = 'bar';
                vis.appendChild(b);
                bars.push(b);
            }
        }

        function bindUi() {
            volumeSlider.addEventListener('input', () => {
                volume = volumeSlider.value / 100;
                volumeDisplay.textContent = volumeSlider.value + '%';
                if (audioEl) audioEl.volume = volume;
            });
            enableBtn.addEventListener('click', joinStream);
            muteBtn.addEventListener('click', toggleMute);
        }

        function initSocket() {
            socket = io();
            socket.on('connect', () => { connectionStatus.textContent = 'Connected'; connectionStatus.style.color = 'var(--success)'; });
            socket.on('disconnect', () => { connectionStatus.textContent = 'Disconnected'; connectionStatus.style.color = 'var(--danger)'; setStatus('Disconnected', 'error'); teardown(); });
            socket.on('no-host', () => { setStatus('No host', 'error'); flash('No host streaming'); enableBtn.style.display = 'block'; });
            socket.on('host-left', () => { setStatus('Host left', 'error'); teardown(); });
            socket.on('host-stopped', () => { setStatus('Host stopped', ''); teardown(); });
            socket.on('host-streaming', () => { if (enableBtn.style.display === 'none') socket.emit('viewer-join'); });
            socket.on('webrtc-offer', async ({ sdp, hostId }) => { hostIdRef = hostId; await ensurePeer(); await pc.setRemoteDescription(new RTCSessionDescription(sdp)); const answer = await pc.createAnswer(); await pc.setLocalDescription(answer); socket.emit('webrtc-answer', { hostId, sdp: answer }); });
            socket.on('webrtc-ice-candidate', ({ candidate, from }) => { if (pc && candidate && from === hostIdRef) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => { }); });
            socket.on('stats', ({ viewerCount }) => { if (clientsCount) clientsCount.textContent = `${viewerCount} listeners`; });
        }

        async function joinStream() { enableBtn.style.display = 'none'; muteBtn.style.display = 'block'; setStatus('Joining...', ''); socket.emit('viewer-join'); }

        async function ensurePeer() {
            if (pc) return;
            pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
            pc.onicecandidate = e => { if (e.candidate && hostIdRef) socket.emit('webrtc-ice-candidate', { targetId: hostIdRef, candidate: e.candidate }); };
            pc.ontrack = e => {
                if (!audioEl) { audioEl = document.createElement('audio'); audioEl.autoplay = true; audioEl.playsInline = true; audioEl.controls = false; audioEl.style.display = 'none'; audioEl.volume = volume; document.body.appendChild(audioEl); }
                audioEl.srcObject = e.streams[0];
                audioEl.play().catch(() => { setStatus('Tap Enable', 'error'); });
                setStatus('Live Audio', 'live');
                animate();
            };
            pc.onconnectionstatechange = () => { if (['failed', 'disconnected', 'closed'].includes(pc.connectionState)) teardown(); };
        }

        function toggleMute() { muted = !muted; if (audioEl) audioEl.muted = muted; muteBtn.textContent = muted ? 'Unmute' : 'Mute'; }

        function teardown() {
            if (pc) { pc.close(); pc = null; }
            if (audioEl) { audioEl.srcObject = null; audioEl.remove(); audioEl = null; }
            bars.forEach(b => b.style.height = '4px');
            enableBtn.style.display = 'block';
            muteBtn.style.display = 'none';
            setStatus('Waiting...', '');
        }

        function animate() {
            const step = () => {
                if (!pc || !audioEl || audioEl.paused) return;
                bars.forEach(b => { b.style.height = (Math.random() * 100) + '%'; });
                requestAnimationFrame(step);
            };
            requestAnimationFrame(step);
            updateStatsLoop();
        }

        async function updateStatsLoop() {
            if (!pc) return;
            try {
                const stats = await pc.getStats();
                let jitter = '-', rtt = '-', bitrate = '-', loss = '-';
                let inboundRtp; let prevBytes = updateStatsLoop._prevBytes || 0; let prevTime = updateStatsLoop._prevTime || performance.now();
                const now = performance.now();

                stats.forEach(r => {
                    if (r.type === 'remote-inbound-rtp' && r.kind === 'audio') { if (r.jitter) jitter = (r.jitter * 1000).toFixed(1); }
                    if (r.type === 'inbound-rtp' && r.kind === 'audio') { inboundRtp = r; }
                    if (r.type === 'candidate-pair' && r.currentRoundTripTime !== undefined && r.nominated) rtt = (r.currentRoundTripTime * 1000).toFixed(0);
                });

                if (inboundRtp && inboundRtp.bytesReceived != null) {
                    const bytes = inboundRtp.bytesReceived;
                    const deltaBytes = bytes - prevBytes;
                    const deltaTime = now - prevTime;
                    if (deltaTime > 0) bitrate = ((deltaBytes * 8) / deltaTime).toFixed(0);
                    updateStatsLoop._prevBytes = bytes;
                    updateStatsLoop._prevTime = now;
                }

                qualityStats.textContent = `RTT: ${rtt}ms | Jitter: ${jitter}ms | ${bitrate}kbps`;
                socket.emit('listener-stats', { rttMs: rtt, jitterMs: jitter, bitrateKbps: bitrate, fractionLoss: 0 });
            } catch (_) { }
            setTimeout(updateStatsLoop, 1000);
        }

        function flash(msg) { note.textContent = msg; note.classList.add('show'); setTimeout(() => note.classList.remove('show'), 2500); }
    </script>
</body>

</html>