<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Listen to live audio stream">
    <title>Live Audio Share</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body class="listener-page">
    <div class="container">
        <header class="page-header">
            <span class="eyebrow" id="audioStatus">Waiting</span>
            <h1>Audio Stream</h1>
            <p>High fidelity stereo audio</p>
        </header>

        <div id="audioVisualizer" class="visualizer-bars"></div>

        <div class="controls" style="flex-direction:column;width:100%;gap:12px">
            <button id="enableAudio" class="btn btn-primary" style="width:100%;justify-content:center">
                Enable Audio
            </button>
            <button id="muteAudio" class="btn btn-secondary" style="width:100%;justify-content:center" hidden>
                Mute
            </button>
            <div style="width:100%;display:flex;align-items:center;gap:12px;margin-top:8px">
                <span style="font-size:0.8rem;color:#909090">VOL</span>
                <input id="volumeSlider" type="range" min="0" max="100" value="100">
                <span id="volumeDisplay" style="font-size:0.8rem;color:#909090;min-width:40px">100%</span>
            </div>
        </div>

        <footer style="text-align:center;margin-top:40px">
            <div id="connectionStatus" style="font-size:0.8rem;color:#aaa">Connecting...</div>
            <div id="clientsCount" style="font-size:0.75rem;color:#909090;margin-top:4px">0 listeners</div>
            <div id="qualityStats"
                style="font-family:'Roboto Mono',monospace;font-size:0.7rem;color:#909090;margin-top:12px"></div>
        </footer>
    </div>

    <div id="notification" class="notification"></div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        (() => {
            'use strict';

            const $ = id => document.getElementById(id);
            const dom = {
                status: $('audioStatus'),
                connection: $('connectionStatus'),
                clients: $('clientsCount'),
                visualizer: $('audioVisualizer'),
                volume: $('volumeSlider'),
                volumeDisplay: $('volumeDisplay'),
                enableBtn: $('enableAudio'),
                muteBtn: $('muteAudio'),
                notification: $('notification'),
                qualityStats: $('qualityStats')
            };

            let socket, pc, audioEl, audioContext, analyser, hostId = null;
            let muted = false, volume = 1;
            const bars = [];

            const setStatus = (msg, type) => {
                dom.status.textContent = msg;
                dom.status.style.color = type === 'error' ? '#f87171' : type === 'live' ? '#4ade80' : '#fff';
            };

            const flash = msg => {
                dom.notification.textContent = msg;
                dom.notification.classList.add('show');
                setTimeout(() => dom.notification.classList.remove('show'), 3000);
            };

            // Enhance SDP for maximum Opus quality
            const enhanceOpusSDP = (sdp) => {
                const opusFmtp = 'minptime=10;stereo=1;sprop-stereo=1;maxaveragebitrate=510000;maxplaybackrate=48000;cbr=0;useinbandfec=0;usedtx=0';
                const lines = sdp.split('\r\n');
                const result = [];
                let opusPayload = null;

                for (const line of lines) {
                    if (line.includes('opus/48000/2')) {
                        const match = line.match(/rtpmap:(\d+)/);
                        if (match) opusPayload = match[1];
                    }
                }

                if (!opusPayload) return sdp;

                let addedFmtp = false;
                for (const line of lines) {
                    if (line.startsWith(`a=fmtp:${opusPayload}`)) {
                        result.push(`a=fmtp:${opusPayload} ${opusFmtp}`);
                        addedFmtp = true;
                    } else {
                        result.push(line);
                        if (!addedFmtp && line.includes(`rtpmap:${opusPayload} opus`)) {
                            result.push(`a=fmtp:${opusPayload} ${opusFmtp}`);
                            addedFmtp = true;
                        }
                    }
                }

                return result.join('\r\n');
            };

            const initBars = () => {
                dom.visualizer.innerHTML = '';
                for (let i = 0; i < 32; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    dom.visualizer.appendChild(bar);
                    bars.push(bar);
                }
            };

            const initSocket = () => {
                socket = io();

                socket.on('connect', () => {
                    dom.connection.textContent = 'Connected';
                    dom.connection.style.color = '#4ade80';
                });

                socket.on('disconnect', () => {
                    dom.connection.textContent = 'Disconnected';
                    dom.connection.style.color = '#f87171';
                    setStatus('Disconnected', 'error');
                    teardown();
                });

                socket.on('no-host', () => {
                    setStatus('No host', 'error');
                    flash('No host streaming');
                    dom.enableBtn.hidden = false;
                });

                socket.on('host-left', () => { setStatus('Host left', 'error'); teardown(); });
                socket.on('host-stopped', () => { setStatus('Stopped', ''); teardown(); });
                socket.on('host-streaming', () => { if (dom.enableBtn.hidden) socket.emit('viewer-join'); });

                socket.on('webrtc-offer', async ({ sdp, hostId: hid }) => {
                    hostId = hid;
                    await setupPeerConnection();

                    // Enhance the incoming offer SDP
                    const enhancedOffer = enhanceOpusSDP(sdp);
                    await pc.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: enhancedOffer }));

                    const answer = await pc.createAnswer();

                    // Enhance the answer SDP to request maximum quality
                    answer.sdp = enhanceOpusSDP(answer.sdp);

                    await pc.setLocalDescription(answer);
                    socket.emit('webrtc-answer', { hostId, sdp: answer });
                });

                socket.on('webrtc-ice-candidate', ({ candidate, from }) => {
                    if (pc && candidate && from === hostId) {
                        pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(() => { });
                    }
                });

                socket.on('stats', ({ viewerCount }) => {
                    dom.clients.textContent = `${viewerCount} listeners`;
                });
            };

            const setupPeerConnection = async () => {
                if (pc) return;

                pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });

                pc.onicecandidate = e => {
                    if (e.candidate && hostId) {
                        socket.emit('webrtc-ice-candidate', { targetId: hostId, candidate: e.candidate });
                    }
                };

                pc.ontrack = e => {
                    const stream = e.streams[0];

                    // Create audio element
                    if (!audioEl) {
                        audioEl = document.createElement('audio');
                        audioEl.autoplay = true;
                        audioEl.playsInline = true;
                        document.body.appendChild(audioEl);
                    }

                    audioEl.srcObject = stream;
                    audioEl.volume = volume;

                    // Create audio context for visualization
                    if (!audioContext) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: 48000
                        });
                        analyser = audioContext.createAnalyser();
                        analyser.fftSize = 64;

                        const source = audioContext.createMediaStreamSource(stream);
                        source.connect(analyser);
                        // Don't connect to destination - audio element handles playback
                    }

                    audioEl.play().catch(() => setStatus('Tap to enable', 'error'));
                    setStatus('LIVE', 'live');
                    animate();
                };

                pc.onconnectionstatechange = () => {
                    const state = pc.connectionState;
                    if (['failed', 'disconnected', 'closed'].includes(state)) {
                        teardown();
                    }
                };
            };

            const joinStream = () => {
                dom.enableBtn.hidden = true;
                dom.muteBtn.hidden = false;
                setStatus('Joining...', '');
                socket.emit('viewer-join');
            };

            const toggleMute = () => {
                muted = !muted;
                if (audioEl) audioEl.muted = muted;
                dom.muteBtn.textContent = muted ? 'Unmute' : 'Mute';
            };

            const teardown = () => {
                if (pc) { pc.close(); pc = null; }
                if (audioEl) { audioEl.srcObject = null; audioEl.remove(); audioEl = null; }
                if (audioContext) { audioContext.close(); audioContext = null; analyser = null; }
                bars.forEach(b => b.style.height = '4px');
                dom.enableBtn.hidden = false;
                dom.muteBtn.hidden = true;
                setStatus('Waiting', '');
            };

            const animate = () => {
                if (!analyser) return;

                const data = new Uint8Array(analyser.frequencyBinCount);

                const step = () => {
                    if (!pc || !audioEl || audioEl.paused) return;

                    analyser.getByteFrequencyData(data);

                    // Map frequency data to bars
                    const barCount = bars.length;
                    const binSize = Math.floor(data.length / barCount);

                    for (let i = 0; i < barCount; i++) {
                        let sum = 0;
                        for (let j = 0; j < binSize; j++) {
                            sum += data[i * binSize + j];
                        }
                        const avg = sum / binSize;
                        bars[i].style.height = `${Math.max(4, (avg / 255) * 100)}%`;
                    }

                    requestAnimationFrame(step);
                };

                requestAnimationFrame(step);
                statsLoop();
            };

            const statsLoop = async () => {
                if (!pc) return;

                try {
                    const stats = await pc.getStats();
                    let jitter = '-', rtt = '-', bitrate = '-', codec = '-';
                    let inbound;
                    const now = performance.now();
                    const prevBytes = statsLoop._bytes || 0;
                    const prevTime = statsLoop._time || now;

                    stats.forEach(r => {
                        if (r.type === 'inbound-rtp' && r.kind === 'audio') {
                            inbound = r;
                            if (r.jitter) jitter = (r.jitter * 1000).toFixed(1);
                        }
                        if (r.type === 'candidate-pair' && r.currentRoundTripTime !== undefined && r.nominated) {
                            rtt = (r.currentRoundTripTime * 1000).toFixed(0);
                        }
                        if (r.type === 'codec' && r.mimeType?.includes('opus')) {
                            codec = 'Opus';
                            if (r.channels === 2) codec += ' Stereo';
                        }
                    });

                    if (inbound?.bytesReceived != null) {
                        const delta = inbound.bytesReceived - prevBytes;
                        const dt = now - prevTime;
                        if (dt > 0) bitrate = ((delta * 8) / dt).toFixed(0);
                        statsLoop._bytes = inbound.bytesReceived;
                        statsLoop._time = now;
                    }

                    dom.qualityStats.textContent = `${codec} | ${bitrate}kbps | RTT ${rtt}ms | Jitter ${jitter}ms`;
                    socket.emit('listener-stats', { rttMs: rtt, jitterMs: jitter, bitrateKbps: bitrate });
                } catch { }

                setTimeout(statsLoop, 1000);
            };

            document.addEventListener('DOMContentLoaded', () => {
                initBars();
                initSocket();

                dom.volume.addEventListener('input', () => {
                    volume = dom.volume.value / 100;
                    dom.volumeDisplay.textContent = `${dom.volume.value}%`;
                    if (audioEl) audioEl.volume = volume;
                });

                dom.enableBtn.addEventListener('click', joinStream);
                dom.muteBtn.addEventListener('click', toggleMute);
            });
        })();
    </script>
</body>

</html>